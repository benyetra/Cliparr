import { FastifyInstance } from 'fastify';
import { db, schema } from '../db/index.js';
import { eq } from 'drizzle-orm';
import { config } from '../config.js';
import { verifyClipToken, generateSegmentToken, verifySegmentToken } from '../services/token.js';
import { readFile, stat } from 'fs/promises';
import { createReadStream } from 'fs';
import { join } from 'path';
import { createHash } from 'crypto';
import { nanoid } from 'nanoid';

export default async function streamRoutes(app: FastifyInstance) {
  /** HLS master manifest - generates per-session signed segment URLs */
  app.get<{ Params: { clipId: string }; Querystring: { t: string } }>(
    '/stream/:clipId/master.m3u8',
    async (request, reply) => {
      const { clipId } = request.params;
      const token = request.query.t;

      const clip = await validateClipAccess(clipId, token);
      if (!clip) {
        return reply.status(410).send({ error: 'Clip expired or not found' });
      }

      // Read the master playlist generated by FFmpeg
      const masterPath = join(config.paths.clips, clip.hlsPath!, 'master.m3u8');
      let manifest: string;
      try {
        manifest = await readFile(masterPath, 'utf-8');
      } catch {
        return reply.status(404).send({ error: 'Clip not ready' });
      }

      // Rewrite variant playlist URLs to include signed tokens
      manifest = manifest.replace(
        /v(\d+)\/playlist\.m3u8/g,
        (_, variant) => {
          const segToken = generateSegmentToken(clipId, `v${variant}`);
          return `v${variant}/playlist.m3u8?t=${segToken}`;
        },
      );

      reply.header('Content-Type', 'application/vnd.apple.mpegurl');
      reply.header('Cache-Control', 'no-cache');
      return reply.send(manifest);
    },
  );

  /** HLS variant playlist */
  app.get<{ Params: { clipId: string; variant: string }; Querystring: { t: string } }>(
    '/stream/:clipId/:variant/playlist.m3u8',
    async (request, reply) => {
      const { clipId, variant } = request.params;
      const token = request.query.t;

      // Verify segment-level token
      const payload = verifySegmentToken(token);
      if (!payload || payload.clipId !== clipId) {
        return reply.status(403).send({ error: 'Invalid segment token' });
      }

      const playlistPath = join(config.paths.clips, clipId, variant, 'playlist.m3u8');
      let manifest: string;
      try {
        manifest = await readFile(playlistPath, 'utf-8');
      } catch {
        return reply.status(404).send({ error: 'Playlist not found' });
      }

      // Rewrite segment URLs to include signed tokens
      manifest = manifest.replace(
        /(seg\d+\.ts)/g,
        (_, segment) => {
          const segToken = generateSegmentToken(clipId, `${variant}/${segment}`);
          return `${segment}?t=${segToken}`;
        },
      );

      reply.header('Content-Type', 'application/vnd.apple.mpegurl');
      reply.header('Cache-Control', 'no-cache');
      return reply.send(manifest);
    },
  );

  /** Serve individual HLS segments */
  app.get<{ Params: { clipId: string; variant: string; segment: string }; Querystring: { t: string } }>(
    '/stream/:clipId/:variant/:segment',
    async (request, reply) => {
      const { clipId, variant, segment } = request.params;
      const token = request.query.t;

      // Verify per-segment token
      const payload = verifySegmentToken(token);
      if (!payload || payload.clipId !== clipId) {
        return reply.status(403).send({ error: 'Invalid segment token' });
      }

      const segmentPath = join(config.paths.clips, clipId, variant, segment);
      try {
        const data = await readFile(segmentPath);
        reply.header('Content-Type', 'video/mp2t');
        reply.header('Cache-Control', 'public, max-age=3600');
        return reply.send(data);
      } catch {
        return reply.status(404).send({ error: 'Segment not found' });
      }
    },
  );

  /** Serve MP4 for OG video embeds (iMessage inline playback, social previews) */
  app.get<{ Params: { clipId: string }; Querystring: { t: string } }>(
    '/stream/:clipId/video.mp4',
    async (request, reply) => {
      const { clipId } = request.params;
      const token = request.query.t;

      const clip = await validateClipAccess(clipId, token);
      if (!clip) {
        return reply.status(410).send({ error: 'Clip expired or not found' });
      }

      const mp4Path = join(config.paths.clips, clipId, 'clip.mp4');
      try {
        const fileStat = await stat(mp4Path);
        const range = request.headers.range;

        if (range) {
          // Support range requests for seeking/streaming
          const parts = range.replace(/bytes=/, '').split('-');
          const start = parseInt(parts[0], 10);
          const end = parts[1] ? parseInt(parts[1], 10) : fileStat.size - 1;
          const chunkSize = end - start + 1;

          reply.status(206);
          reply.header('Content-Range', `bytes ${start}-${end}/${fileStat.size}`);
          reply.header('Accept-Ranges', 'bytes');
          reply.header('Content-Length', chunkSize);
          reply.header('Content-Type', 'video/mp4');
          reply.header('Cache-Control', 'public, max-age=3600');
          return reply.send(createReadStream(mp4Path, { start, end }));
        }

        reply.header('Content-Type', 'video/mp4');
        reply.header('Content-Length', fileStat.size);
        reply.header('Accept-Ranges', 'bytes');
        reply.header('Cache-Control', 'public, max-age=3600');
        return reply.send(createReadStream(mp4Path));
      } catch {
        return reply.status(404).send({ error: 'MP4 not available' });
      }
    },
  );

  /** Track view analytics */
  app.post<{ Params: { clipId: string }; Body: { watchDurationMs: number; watchPercentage: number }; Querystring: { t: string } }>(
    '/stream/:clipId/view',
    async (request, reply) => {
      const { clipId } = request.params;
      const token = request.query.t;

      const clip = await validateClipAccess(clipId, token);
      if (!clip) {
        return reply.status(410).send({ error: 'Clip expired or not found' });
      }

      // Hash IP for privacy
      const ip = request.ip || 'unknown';
      const dailySalt = new Date().toISOString().split('T')[0];
      const sessionHash = createHash('sha256').update(`${ip}:${dailySalt}`).digest('hex').slice(0, 16);

      await db.insert(schema.clipViews).values({
        id: nanoid(),
        clipId,
        sessionHash,
        watchDurationMs: request.body.watchDurationMs || 0,
        watchPercentage: request.body.watchPercentage || 0,
        userAgent: request.headers['user-agent'] || null,
      });

      // Increment view count
      await db.update(schema.clips)
        .set({ viewCount: clip.viewCount + 1 })
        .where(eq(schema.clips.id, clipId));

      return reply.send({ ok: true });
    },
  );
}

async function validateClipAccess(clipId: string, token: string) {
  if (!token) return null;

  const payload = verifyClipToken(token);
  if (!payload || payload.clipId !== clipId) return null;

  const clip = await db.query.clips.findFirst({
    where: eq(schema.clips.id, clipId),
  });

  if (!clip) return null;
  if (clip.status !== 'ready') return null;
  if (clip.expiresAt < new Date()) return null;
  if (clip.maxViews && clip.viewCount >= clip.maxViews) return null;

  return clip;
}
